import { Random, RngStateBuiltin } from "@reside-ic/random";
import { ArrayState, SystemState, SystemSubState } from "./SystemState";
import { SystemSimulateResult } from "./SystemSimulateResult.ts";
import { DiscreteGenerator } from "./interfaces/DiscreteGenerator.ts";
import { Packer } from "./Packer";
import { System } from "./interfaces/System.ts";
import { checkIntegerInRange, arrayStateToArray, checkTimes, checkIndicesForMax } from "./utils.ts";
import { DustParameterError } from "./errors.ts";

/**
 * Implementation of {@link System} for discrete systems. Manages particle states generated by stateless generators.
 *
 * @typeParam TShared Values which are shared between all particles in a group and are not mutated by them -
 * the model parameter values for that group
 *
 * @typeParam TInternal Internal state values which can be mutated by generators, used to improve efficiency of the
 * system by e.g. caching calculation results for use by other particles.
 */
export class DiscreteSystem<TShared, TInternal> implements System {
    protected readonly _generator: DiscreteGenerator<TShared, TInternal>;
    protected readonly _nParticles: number;
    protected readonly _nGroups: number;
    protected readonly _statePacker: Packer;
    protected readonly _state: SystemState;
    protected readonly _dt: number;
    protected _shared: TShared[];
    protected readonly _internal: TInternal[];
    protected readonly _random: Random;
    protected _time: number;

    /**
     *
     * @param generator Generator (model) implementation for the System
     * @param shared Array of TShared, each representing the parameters for a group of particles
     * @param time Initial time for the system
     * @param dt Time step to be used when updating the system
     * @param nParticles Number of particles per group
     * @param random Random number generator which may be used by the generator
     */
    constructor(
        generator: DiscreteGenerator<TShared, TInternal>,
        shared: TShared[],
        time: number,
        dt: number,
        nParticles: number,
        random?: Random
    ) {
        checkIntegerInRange("Number of particles", nParticles, 1);

        this._generator = generator;
        this._time = time;
        this._dt = dt;
        this._nParticles = nParticles; // number of particles per parameter set
        this._nGroups = shared.length; // number of parameter sets
        this._statePacker = generator.packingState(shared[0]);
        const nState = this._statePacker.length; // number of state elements in the packer, as defined by the generator

        this._state = new SystemState(this._nGroups, this._nParticles, nState);
        this._shared = shared;
        this._internal = shared.map((el) => generator.internal(el));

        this._random = random ? random : new Random(new RngStateBuiltin());
    }

    /**
     * Returns the current time of the system
     */
    public get time() {
        return this._time;
    }

    /**
     * Sets the current time of the system
     * @param value
     */
    public set time(value: number) {
        this._time = value;
    }

    /**
     * Returns the current state of all particles in the system
     */
    public get state(): Readonly<SystemState> {
        return this._state as Readonly<SystemState>;
    }

    // helper method to iterate over all particles and execute the provided function
    protected iterateParticles(f: (iGroup: number, iParticle: number) => void) {
        for (let iGroup = 0; iGroup < this._nGroups; iGroup++) {
            for (let iParticle = 0; iParticle < this._nParticles; iParticle++) {
                f(iGroup, iParticle);
            }
        }
    }

    /**
     * Initialises each particle by calling the {@link DiscreteGenerator.initial | initial} method on the generator.
     */
    public setStateInitial(): void {
        this.iterateParticles((iGroup: number, iParticle: number) => {
            const shared = this._shared[iGroup];
            const internal = this._internal[iGroup];
            const state = this._state.getParticle(iGroup, iParticle);
            const arrayState = arrayStateToArray(state);
            this._generator.initial(this._time, shared, internal, arrayState, this._random);
            this._state.setParticle(iGroup, iParticle, arrayState);
        });
    }

    /**
     * Sets new values in the system state
     * @param newState The new state values for all or part of the state. If partial state, the shape must match the
     * values provided in the indices parameters
     * @param groupIndices The group indices, in order, which the first dimension of newState are setting values for.
     * If empty, this means newState provides values for all groups.
     * @param particleIndices The particle indices, in order, which the second dimension of newState are setting values
     * for. If empty, this means newState provides values for all particles.
     * @param stateElementIndices The state element indices, in order, which the second dimension of newState are
     * setting values for. If empty, this means newState provides values for all state elements.
     */
    public setState(
        newState: SystemSubState,
        groupIndices: number[] = [],
        particleIndices: number[] = [],
        stateElementIndices: number[] = []
    ) {
        this._state.setState(newState, groupIndices, particleIndices, stateElementIndices);
    }

    /**
     * Runs the system from its current time to the given time, causing its state to be updated. Calls the
     * {@link DiscreteGenerator.update | update} method on the generator for each particle.
     * @param time The time to run to
     */
    public runToTime(time: number): void {
        if (time < this._time) {
            throw RangeError(`Cannot run to requested time ${time}, which is less than current time ${this._time}.`);
        }
        const nSteps = (time - this._time) / this._dt;
        this.iterateParticles((iGroup: number, iParticle: number) => {
            const shared = this._shared[iGroup];
            const internal = this._internal[iGroup];
            const state = this.runParticle(shared, internal, this._state.getParticle(iGroup, iParticle), nSteps);
            this._state.setParticle(iGroup, iParticle, state);
        });
        this._time = time;
    }

    public simulate(times: number[], stateElementIndices: number[] = []): SystemSimulateResult {
        checkTimes(times, this._time);
        if (stateElementIndices.length) {
            checkIndicesForMax("State Element", stateElementIndices, this._state.nStateElements - 1);
        }

        // Allow case where first time is current time - no progression needed for first result set
        let preRunSaveValues = times[0] === this._time;

        const stateIndicesToReturn = stateElementIndices.length ? stateElementIndices : [...Array(this._state.nStateElements).keys()];

        const result = new SystemSimulateResult(this._nGroups, this._nParticles, stateIndicesToReturn.length, times.length);
        times.forEach((t, iTime) => {
            if (preRunSaveValues) {
                preRunSaveValues = false
            } else {
                this.runToTime(t);
            }

            this.iterateParticles((iGroup: number, iParticle: number) => {
                const particle = this._state.getParticle(iGroup, iParticle);
                const stateValues = stateIndicesToReturn.map((index) => particle.get(index));
                result.setValuesForTime(iGroup, iParticle, iTime, stateValues);
            });
        });
        return result;
    }

    private runParticle(shared: TShared, internal: TInternal, particleState: ArrayState, nSteps: number): number[] {
        let state = arrayStateToArray(particleState);
        let stateNext = [...state];
        let time = this._time;
        for (let i = 0; i < nSteps; i++) {
            this._generator.update(time, this._dt, state, shared, internal, stateNext, this._random);
            time += this._dt;
            const tmp = state;
            state = stateNext;
            stateNext = tmp;
        }
        return state;
    }

    /**
     * Updates shared (parameter) values for all groups in the system.
     * @param newShared Updated parameter values. The length must match the existing number of groups in the system.
     */
    public updateShared(newShared: TShared[]) {
        if (newShared.length !== this._shared.length) {
            throw new DustParameterError(
                "New shared value must be same length as previous value. " +
                    `Expected ${this._shared.length} but got ${newShared.length}.`
            );
        }
        for (let i = 0; i < this._shared.length; i++) {
            this._generator.updateShared(this._shared[i], newShared[i]);
        }
    }
}
