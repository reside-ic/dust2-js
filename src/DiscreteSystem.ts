import { Random, RngStateBuiltin } from "@reside-ic/random";
import { ParticleState, SystemState } from "./SystemState";
import { DiscreteGenerator } from "./interfaces/DiscreteGenerator.ts";
import { Packer } from "./Packer";
import { System } from "./interfaces/System.ts";
import { checkIntegerInRange, particleStateToArray } from "./utils.ts";

/**
 * Implementation of {@link System} for discrete systems. Manages particle states generated by stateless generators.
 *
 * @typeParam TShared Values which are shared between all particles in a group and are not mutated by them -
 * the model parameter values for that group
 *
 * @typeParam TInternal Internal state values which can be mutated by generators, used to improve efficiency of the
 * system by e.g. caching calculation results for use by other particles.
 */
export class DiscreteSystem<TShared, TInternal> implements System {
    protected readonly _generator: DiscreteGenerator<TShared, TInternal>;
    protected readonly _nParticles: number;
    protected readonly _nGroups: number;
    protected readonly _statePacker: Packer;
    protected readonly _state: SystemState;
    protected readonly _dt: number;
    protected readonly _shared: TShared[];
    protected readonly _internal: TInternal[];
    protected readonly _random: Random;
    protected _time: number;

    /**
     *
     * @param generator Generator (model) implementation for the System
     * @param shared Array of TShared, each representing the parameters for a group of particles
     * @param time Initial time for the system
     * @param dt Time step to be used when updating the system
     * @param nParticles Number of particles per group
     * @param random Random number generator which may be used by the generator
     */
    constructor(
        generator: DiscreteGenerator<TShared, TInternal>,
        shared: TShared[],
        time: number,
        dt: number,
        nParticles: number,
        random?: Random
    ) {
        checkIntegerInRange("Number of particles", nParticles, 1);

        this._generator = generator;
        this._time = time;
        this._dt = dt;
        this._nParticles = nParticles; // number of particles per parameter set
        this._nGroups = shared.length; // number of parameter sets
        this._statePacker = generator.packingState(shared[0]);
        const nState = this._statePacker.length; // number of state elements in the packer, as defined by the generator

        this._state = new SystemState(this._nGroups, this._nParticles, nState);
        this._shared = shared;
        this._internal = shared.map((el) => generator.internal(el));

        this._random = random ? random : new Random(new RngStateBuiltin());
    }

    /**
     * Returns the current time of the system
     */
    public get time() {
        return this._time;
    }

    /**
     * Sets the current time of the system
     * @param value
     */
    public set time(value: number) {
        this._time = value;
    }

    /**
     * Returns the current state of all particles in the system
     */
    public get state(): Readonly<SystemState> {
        return this._state as Readonly<SystemState>;
    }

    // helper method to iterate over all particles and execute the provided function
    protected iterateParticles(f: (iGroup: number, iParticle: number) => void) {
        for (let iGroup = 0; iGroup < this._nGroups; iGroup++) {
            for (let iParticle = 0; iParticle < this._nParticles; iParticle++) {
                f(iGroup, iParticle);
            }
        }
    }

    /**
     * Initialises each particle by calling the {@link DiscreteGenerator.initial | initial} method on the generator.
     */
    public setStateInitial(): void {
        this.iterateParticles((iGroup: number, iParticle: number) => {
            const shared = this._shared[iGroup];
            const internal = this._internal[iGroup];
            const state = this._state.getParticle(iGroup, iParticle);
            const arrayState = particleStateToArray(state);
            this._generator.initial(this._time, shared, internal, arrayState, this._random);
            this._state.setParticle(iGroup, iParticle, arrayState);
        });
    }

    /**
     * Runs the system from its current time to the given time, causing its state to be updated. Calls the
     * {@link DiscreteGenerator.update | update} method on the generator for each particle.
     * @param time The time to run to
     */
    public runToTime(time: number): void {
        if (time < this._time) {
            throw RangeError(`Cannot run to requested time ${time}, which is less than current time ${this._time}.`);
        }
        const nSteps = (time - this._time) / this._dt;
        this.iterateParticles((iGroup: number, iParticle: number) => {
            const shared = this._shared[iGroup];
            const internal = this._internal[iGroup];
            const state = this.runParticle(shared, internal, this._state.getParticle(iGroup, iParticle), nSteps);
            this._state.setParticle(iGroup, iParticle, state);
        });
        this._time = time;
    }

    private runParticle(shared: TShared, internal: TInternal, particleState: ParticleState, nSteps: number): number[] {
        let state = particleStateToArray(particleState);
        let stateNext = [...state];
        let time = this._time;
        for (let i = 0; i < nSteps; i++) {
            this._generator.update(time, this._dt, state, shared, internal, stateNext, this._random);
            time += this._dt;
            const tmp = state;
            state = stateNext;
            stateNext = tmp;
        }
        return state;
    }
}
