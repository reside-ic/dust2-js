import ndarray from "ndarray";
import * as dopri from "dopri";
import { Random, RngStateBuiltin } from "@reside-ic/random";
import { ParticleState, SystemState, SystemSubState } from "./SystemState.ts";
import { Packer } from "./Packer.ts";
import { SystemInterface } from "./interfaces/System.ts";
import {
    checkIndicesForMax,
    checkIntegerInRange,
    checkTimes,
    floatIsDivisibleBy,
    particleStateToArray
} from "./utils.ts";
import { DustParameterError } from "./errors.ts";
import { ZeroEvery } from "./zero.ts";
import { SystemSimulateResult } from "./SystemSimulateResult.ts";
import { GeneratorConfig } from "./interfaces/generators/Generator.ts";
import { DiscreteGenerator } from "./interfaces/generators/DiscreteGenerator.ts";
import { ContinuousGeneratorDDE, ContinuousGeneratorODE } from "./interfaces/generators/ContinuousGenerator.ts";

/**
 * Implementation of {@link SystemInterface} for continuous or discrete systems. Manages particle states generated by
 * stateless generators.
 *
 * @copyDoc BaseGenerator
 */
export class System<TShared, TInternal, TData> implements SystemInterface<TData> {
    protected readonly _generatorCfg: GeneratorConfig<TShared, TInternal, TData>;
    protected readonly _nParticles: number;
    protected readonly _nGroups: number;
    protected readonly _statePacker: Packer;
    protected readonly _state: SystemState;
    protected readonly _dt: number;
    protected _shared: TShared[];
    protected readonly _internal: TInternal[];
    protected readonly _zeroEvery: ZeroEvery[];
    protected readonly _random: Random;
    protected _time: number;
    protected _solvers: dopri.Dopri[][] | null[][];
    protected _rhsVariablesLength: number;

    private constructor(
        generatorCfg: GeneratorConfig<TShared, TInternal, TData>,
        shared: TShared[],
        time: number,
        dt: number,
        nParticles: number,
        nRhsVariables?: number,
        random?: Random
    ) {
        checkIntegerInRange("Number of particles", nParticles, 1);

        this._generatorCfg = generatorCfg;
        const { generator } = generatorCfg;

        this._time = time;
        this._dt = dt;
        this._nParticles = nParticles; // number of particles per parameter set
        this._nGroups = shared.length; // number of parameter sets
        this._statePacker = generator.packingState(shared[0]);
        const nState = this._statePacker.length; // number of state elements in the packer, as defined by the generator

        this._state = new SystemState(this._nGroups, this._nParticles, nState);
        this._shared = shared;
        this._internal = shared.map(generator.internal);
        this._zeroEvery = generator.getZeroEvery ? shared.map(generator.getZeroEvery) : shared.map(() => []);
        this._solvers = shared.map(() => Array(nParticles).fill(null));

        const nVariables = this._statePacker.nVariables;
        this._rhsVariablesLength = this._statePacker.flatLengthFromStart(nRhsVariables ?? nVariables);
        this._random = random ? random : new Random(new RngStateBuiltin());
    }

    /**
     * @param generator Discrete generator (model) implementation for the System
     * @param shared Array of TShared, each representing the parameters for a group of particles
     * @param time Initial time for the system
     * @param dt Time step to be used when updating the system
     * @param nParticles Number of particles per group
     * @param nRhsVariables Number of variables to feed into the rhs function of the generator. This
     * may be less than the number of variables of the system if some variables are calculated from
     * the output function of the generator
     * @param random Random number generator which may be used by the generator
     */
    static createDiscrete<TShared, TInternal, TData = null>(
        generator: DiscreteGenerator<TShared, TInternal, TData>,
        shared: TShared[],
        time: number,
        dt: number,
        nParticles: number,
        nRhsVariables?: number,
        random?: Random
    ) {
        const generatorCfg: GeneratorConfig<TShared, TInternal, TData> = {
            generator,
            isContinuous: false,
            hasDelays: false
        };
        return new System<TShared, TInternal, TData>(generatorCfg, shared, time, dt, nParticles, nRhsVariables, random);
    }

    /**
     * @param generator Continuous ODE generator (model) implementation for the System
     * @copyDoc System.createDiscrete
     */
    static createODE<TShared, TInternal, TData = null>(
        generator: ContinuousGeneratorODE<TShared, TInternal, TData>,
        shared: TShared[],
        time: number,
        dt: number,
        nParticles: number,
        nRhsVariables?: number,
        random?: Random
    ) {
        const generatorCfg: GeneratorConfig<TShared, TInternal, TData> = {
            generator,
            isContinuous: true,
            hasDelays: false
        };
        return new System<TShared, TInternal, TData>(generatorCfg, shared, time, dt, nParticles, nRhsVariables, random);
    }

    /**
     * @param generator Continuous DDE generator (model) implementation for the System
     * @copyDoc System.createDiscrete
     */
    static createDDE<TShared, TInternal, TData = null>(
        generator: ContinuousGeneratorDDE<TShared, TInternal, TData>,
        shared: TShared[],
        time: number,
        dt: number,
        nParticles: number,
        nRhsVariables?: number,
        random?: Random
    ) {
        const generatorCfg: GeneratorConfig<TShared, TInternal, TData> = {
            generator,
            isContinuous: true,
            hasDelays: true
        };
        return new System<TShared, TInternal, TData>(generatorCfg, shared, time, dt, nParticles, nRhsVariables, random);
    }

    /**
     * Returns the current time of the system
     */
    public get time() {
        return this._time;
    }

    /**
     * Sets the current time of the system
     * @param value
     */
    public set time(value: number) {
        this._time = value;
    }

    /**
     * Returns the current state of all particles in the system
     */
    public get state(): Readonly<SystemState> {
        return this._state as Readonly<SystemState>;
    }

    // helper method to iterate over all particles and execute the provided function
    protected iterateParticles(f: (iGroup: number, iParticle: number) => void) {
        for (let iGroup = 0; iGroup < this._nGroups; iGroup++) {
            for (let iParticle = 0; iParticle < this._nParticles; iParticle++) {
                f(iGroup, iParticle);
            }
        }
    }

    /**
     * Initialises each particle by calling the initial method on the generator and initialises the
     * Dopri solvers if this is a continuous system.
     */
    public setStateInitial(): void {
        this.iterateParticles((iGroup: number, iParticle: number) => {
            const shared = this._shared[iGroup];
            const internal = this._internal[iGroup];
            const state = this._state.getParticle(iGroup, iParticle);
            const arrayState = particleStateToArray(state);
            const { generator, isContinuous, hasDelays } = this._generatorCfg;
            generator.initial(this._time, shared, internal, arrayState, this._random);
            if (isContinuous && !hasDelays) {
                this._solvers[iGroup][iParticle] = new dopri.Dopri(
                    generator.rhs,
                    this._rhsVariablesLength,
                    // these are the control params which will be added in a future ticket: mrc-6742
                    // https://mrc-ide.github.io/dopri-js/interfaces/DopriControlParam.html
                    {},
                    generator.output
                );
            }
            this._state.setParticle(iGroup, iParticle, arrayState);
        });
    }

    /**
     * @copyDoc SystemInterface.setState
     */
    public setState(
        newState: SystemSubState,
        groupIndices: number[] = [],
        particleIndices: number[] = [],
        stateElementIndices: number[] = []
    ) {
        this._state.setState(newState, groupIndices, particleIndices, stateElementIndices);
    }

    /**
     * Runs the system from its current time to the given time, causing its state to be updated. Calls the
     * update method on the generator for each particle.
     *
     * @copyDoc SystemInterface.runToTime
     */
    public runToTime(time: number): void {
        if (time < this._time) {
            throw RangeError(`Cannot run to requested time ${time}, which is less than current time ${this._time}.`);
        }
        if (time === this._time) {
            // Already at the requested time - nothing to do
            return;
        }
        const nSteps = (time - this._time) / this._dt;
        this.iterateParticles((iGroup: number, iParticle: number) => {
            const shared = this._shared[iGroup];
            const internal = this._internal[iGroup];
            const solver = this._solvers[iGroup][iParticle];
            const state = this.runParticle(
                shared,
                internal,
                this._zeroEvery[iGroup],
                this._state.getParticle(iGroup, iParticle),
                nSteps,
                solver
            );
            this._state.setParticle(iGroup, iParticle, state);
        });
        this._time = time;
    }

    /**
     * @copyDoc SystemInterface.simulate
     */
    public simulate(times: number[], stateElementIndices: number[] = []): SystemSimulateResult {
        checkTimes(times, this._time);
        if (stateElementIndices.length) {
            checkIndicesForMax("State Element", stateElementIndices, this._state.nStateElements - 1);
        }

        const stateIndicesToReturn = stateElementIndices.length
            ? stateElementIndices
            : [...Array(this._state.nStateElements).keys()];

        const result = new SystemSimulateResult(
            this._nGroups,
            this._nParticles,
            stateIndicesToReturn.length,
            times.length
        );
        times.forEach((t, iTime) => {
            this.runToTime(t);

            this.iterateParticles((iGroup: number, iParticle: number) => {
                const particle = this._state.getParticle(iGroup, iParticle);
                const stateValues = stateIndicesToReturn.map((index) => particle.get(index));
                result.setValuesForTime(iGroup, iParticle, iTime, stateValues);
            });
        });
        return result;
    }

    private runParticle(
        shared: TShared,
        internal: TInternal,
        zeroEvery: ZeroEvery,
        particleState: ParticleState,
        nSteps: number,
        solver: dopri.Dopri | null
    ): number[] {
        let state = particleStateToArray(particleState);
        let stateNext = [...state];
        let time = this._time;
        for (let i = 0; i < nSteps; i++) {
            zeroEvery.forEach(([frequency, indicesToReset]) => {
                if (floatIsDivisibleBy(time, frequency)) {
                    indicesToReset.forEach((idx) => (state[idx] = 0));
                }
            });
            const nextTime = time + this._dt;
            if (solver) {
                solver.initialise(time, state.slice(0, this._rhsVariablesLength));
                const solution = solver.run(nextTime);
                state = solution([nextTime])[0];
                stateNext = [...state];
            }
            this._generatorCfg.generator.update(time, this._dt, state, shared, internal, stateNext, this._random);
            time = nextTime;
            const tmp = state;
            state = stateNext;
            stateNext = tmp;
        }
        return state;
    }

    /**
     * Updates shared (parameter) values for all groups in the system.
     * @param newShared Updated parameter values. The length must match the existing number of groups in the system.
     */
    public updateShared(newShared: TShared[]) {
        if (newShared.length !== this._shared.length) {
            throw new DustParameterError(
                "New shared value must be same length as previous value. " +
                    `Expected ${this._shared.length} but got ${newShared.length}.`
            );
        }
        for (let i = 0; i < this._shared.length; i++) {
            this._generatorCfg.generator.updateShared(this._shared[i], newShared[i]);
        }
    }

    public compareData(data: TData[] | TData) {
        const { generator } = this._generatorCfg;
        if (generator.compareData) {
            const { compareData } = generator;

            // are we sharing data between all groups
            const isSharedData = !Array.isArray(data) || data.length === 1;
            let sharedData: TData;
            if (isSharedData) {
                sharedData = Array.isArray(data) ? data[0] : data;
            } else {
                if (data.length !== this._nGroups) {
                    throw new RangeError("Expected data to have same length as groups.");
                }
            }

            const result = ndarray(new Array(this._nGroups * this._nParticles), [this._nGroups, this._nParticles]);
            this.iterateParticles((iGroup: number, iParticle: number) => {
                const iData = isSharedData ? sharedData : data[iGroup];
                const state = this._state.getParticle(iGroup, iParticle);
                const shared = this._shared[iGroup];
                const internal = this._internal[iGroup];
                const comparisonValue = compareData(
                    this._time,
                    particleStateToArray(state),
                    iData,
                    shared,
                    internal,
                    this._random
                );
                result.set(iGroup, iParticle, comparisonValue);
            });
            return result;
        } else {
            throw new TypeError("Generator does not specify a compareData function");
        }
    }
}
